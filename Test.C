/* File generated by the BNF Converter (bnfc 2.9.5). */

/************************* Compiler Front-End Test *************************/
/*                                                                         */
/*  This test will parse a file, print the abstract syntax tree, and then  */
/*  pretty-print the result.                                               */
/*                                                                         */
/***************************************************************************/

#include <cstdio>
#include <string>
#include <map>
#include <iostream>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include "ParserError.H"
#include "DataStructure.h"
#include "DataStructure.cpp"
#include "Skeleton.H"
#include "Skeleton.C"

void usage() {
  printf("usage: Call with one of the following argument combinations:\n");
  printf("\t--help\t\tDisplay this help message.\n");
  printf("\t(no arguments)\tParse stdin verbosely.\n");
  printf("\t(files)\t\tParse content of files verbosely.\n");
  printf("\t-s (files)\tSilent mode. Parse content of files silently.\n");
}

// section for processing the tree
void rec_tree(){

}

class IntermediateProgram{
private:

public:
  std::vector<Function*>m_functions;
  IntermediateProgram(){}
  ~IntermediateProgram(){
    for(auto *fn: m_functions)
      delete fn;
  }
};

class MyVisitor:public Skeleton {
private:
  IntermediateProgram * m_program;
  std::vector<Label*> m_labels;
  std::vector<Function*> m_functions;
  std::vector<std::string> m_generated_code;
  std::map<std::string,Variable*> m_symbol_table;
  std::map<Visitable*,Operand> m_nodes_to_operands;
  Function * m_current_fn;
  Argument * m_current_arg;
  std::string m_current_line;
  DataType m_last_visited_type;
  OperandCategory m_last_expr_cat;
  Operation m_current_operation;

public:

  MyVisitor(IntermediateProgram *prog):m_program{prog}{}
  void visitProg(Prog *p) override {
    std::cout<<"Begin Program"<<std::endl;
    p->listtopdef_->accept(this);
    std::cout<<"End Program"<<std::endl;
  }
  
  void visitFnDef(FnDef *p) override {
    m_current_fn = new Function;
    std::cout<<"Begin function definition"<<std::endl;
    std::cout<<"Function name : "<<p->ident_<<std::endl;
    m_current_fn->m_name=p->ident_;
    p->type_->accept(this);
    m_current_fn->m_return_type=m_last_visited_type;
    p->listarg_->accept(this);
    p->block_->accept(this);
    std::cout<<"End function definition"<<std::endl;
    m_functions.push_back(m_current_fn);
  }

  void visitBlk(Blk *p){
    for(auto statement : *p->liststmt_){
      statement->accept(this);
    }
  }

  void visitInt(Int *x) override{
    m_last_visited_type=DataType::INT;
  }

  void visitListArg(ListArg *p) override{
    std::cout<<"List of arguments"<<std::endl;
    for(auto item : *p){
      m_current_arg=new Argument;
      item->accept(this);
      m_current_fn->m_arguments.push_back(m_current_arg);
    }
  }

  virtual void visitAr(Ar *p) override{
    std::cout<<"Argument Identifier: "<<p->ident_<<std::endl;
    m_current_arg->m_identifier=p->ident_;
    p->type_->accept(this);
    m_current_arg->m_type=m_last_visited_type;
  }

  void visitDecl(Decl *p) override{
    p->type_->accept(this);
    for(auto item : *p->listitem_)
      item->accept(this);
  }
  
  void visitInit(Init *p) override {
    Variable *variable = new Variable{p->ident_,m_last_visited_type};
    m_symbol_table[p->ident_]=variable; // if insert then iterator has to be passed 
    p->expr_->accept(this);
    std::cout<<"Initialized Identifier: "<<p->ident_<<std::endl;
    push_triple(Operation::ASSIGN,variable,m_nodes_to_operands[p->expr_]);
    m_current_fn->m_variables.push_back(variable);
  }

  // Przemyslec jak ma dzialc mylabel
  void visitCond(Cond *p) override {
    p->expr_->accept(this);
    Label *jump_to=new Label{m_labels.size()};
    Triple *jf_triple = push_triple(Operation::JF,m_nodes_to_operands.at(p->expr_),{jump_to});
    p->stmt_->accept(this);
    Triple *special_triple=push_triple(Operation::MARKER);
    jf_triple->m_op_2.m_label->m_jump_to = special_triple;
  }

  void visitAss(Ass *ass) override {
    ass->expr_->accept(this);
    m_nodes_to_operands[ass->expr_]=push_triple(Operation::ASSIGN,m_symbol_table[ass->ident_],m_nodes_to_operands[ass->expr_]);
  }

  void visitNoInit(NoInit *p) override {
    std::cout<<"NoInit: "<<p->ident_<<std::endl;
    Variable *variable = new Variable{p->ident_,m_last_visited_type};
    m_symbol_table[p->ident_]=variable;
    m_current_fn->m_variables.push_back(variable);
  }

  std::string type_to_string(DataType dt){
    switch (dt)
    {
    case DataType::INT:
      return "int";
    case DataType::BOOL:
      return "bool";
    case DataType::STRING:
      return "STRING";
    default:
      return "";
      break;
    }
  }
  
  void visitELitInt(ELitInt *p) override{
    Constant constant{p->integer_};
  
    m_nodes_to_operands[p]=constant;
  }

  Triple* push_triple(Operation operation,const Operand &op_1={},const Operand &op_2={}){
    Triple *triple = new Triple{m_current_fn->m_triples.size()+1,operation,op_1,op_2};
    m_current_fn->m_triples.push_back(triple);
    return triple;
  }
  void visitEVar(EVar *p)override{
    m_nodes_to_operands[p] = m_symbol_table[p->ident_]; //lokalnie tymczasowo tworzony jest operand
  }
  void visitEAdd(EAdd *p) override {
    p->expr_1->accept(this);
    p->addop_->accept(this); // here we want to figure the correct operation
    p->expr_2->accept(this);
    
    m_nodes_to_operands[p] = push_triple(m_current_operation,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitEMul(EMul *p) override{
    p->expr_1->accept(this);

    p->mulop_->accept(this);

    p->expr_2->accept(this);
    m_nodes_to_operands[p] = push_triple(m_current_operation,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitLTH(LTH *p) override {
    m_current_operation = Operation::LTH;
  }

  void visitLE(LE *p) override {
    m_current_operation = Operation::LE;
  }

  void visitGTH(GTH *p) override {
    m_current_operation = Operation::GTH;
  }

  void visitGE(GE *p) override {
    m_current_operation = Operation::GE;
  }

  void visitEQU(EQU *p) override{
    m_current_operation = Operation::EQU;
  }

  void visitNE(NE *p) override{
    m_current_operation=Operation::NE;
  }

  void visitERel(ERel *p) override {
    p->relop_->accept(this);
    p->expr_1->accept(this);
    p->expr_2->accept(this);
    Operand op_1 = m_nodes_to_operands.at(p->expr_1);
    Operand op_2 = m_nodes_to_operands.at(p->expr_2);
    
    m_nodes_to_operands[p]=push_triple(m_current_operation,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitEAnd(EAnd *p) override{
    p->expr_1->accept(this);
    p->expr_2->accept(this);
    
    m_nodes_to_operands[p]=push_triple(Operation::AND,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitEOr(EOr *p){
    p->expr_1->accept(this);
    p->expr_2->accept(this);
    
    m_nodes_to_operands[p]=push_triple(Operation::OR,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitPlus(Plus *p) override {
    m_current_operation=Operation::ADD;
  }

  void visitDiv(Div *p) override{
    std::cout<<"Entering DIV: "<<std::endl;
    m_current_operation=Operation::DIV;
  }

  void visitMinus(Minus *p) override{
    m_current_operation=Operation::SUB;
  }

  void visitTimes(Times *p) override {
    m_current_operation=Operation::MUL;
  }

  void visitMod(Mod *mod) override {
    m_current_operation=Operation::MOD;
  }
  
  void print_functions(){
    for(auto *fn : m_functions){ //for readability
      std::cout<<"Function name: "<<fn->m_name<<std::endl;
      std::cout<<"Function return type: "<<type_to_string(fn->m_return_type)<<std::endl;
      std::cout<<"Arguments: "<<std::endl;
      for(auto *arg : fn->m_arguments)
        std::cout<<" Indentifier: "<<arg->m_identifier<<"Type :"<<type_to_string(arg->m_type)<<std::endl;
    }
  }

  void print_constant(const Constant &constant){
    switch (constant.m_type)
    {
    case DataType::INT:{
      std::cout<<"INT("<<constant.u.integer<<") ";
      break;
    }
    case DataType::BOOL:
      std::cout<<"BOOL : "<<constant.u.boolean;
      break;
    case DataType::STRING:
      std::cout<<"STRING : "<<constant.u.str;
      break;
    default:
      break;
    }
  }
  
  void print_operand(const Operand &operand){
    //  CONSTANT,VARIABLE,TRIPLE,EMPTY
    switch (operand.m_category)
      {
      case OperandCategory::CONSTANT:
        print_constant(operand.m_constant);
        break;
      case OperandCategory::VARIABLE:
        std::cout<<operand.m_var->m_ident<<" ";
        break;
      case OperandCategory::TRIPLE:
        std::cout<<"t"<<operand.m_triple->m_index<<" ";
        break;
      case OperandCategory::EMPTY:
        std::cout<<"- ";
        break;
      case OperandCategory::LABEL:
        if(operand.m_label->m_jump_to!=nullptr)
          std::cout<<"t"<<operand.m_label->m_jump_to->m_index<<" ";
        else
          std::cout<<"No label set ";
        break;
      default:
        throw 0; //it is yet to be changed
        break;
    }
  }

  std::string return_operation(Operation operation){
    switch (operation)
    {
      case Operation::ADD:{
        return " ADD: ";
      case Operation::ASSIGN:
        return " ASSIGN: ";
      case Operation::MUL:
        return " MUL: ";
      case Operation::SUB:
        return " SUB: ";
      case Operation::DIV:
        return " DIV: ";
      case Operation::AND:
        return " AND: ";
      case Operation::OR:
        return " OR: ";
      case Operation::LTH:
        return " LTH: ";
      case Operation::LE:
        return " LE: ";
      case Operation::GTH:
        return " GTH: ";
      case Operation::GE:
        return " GE: ";
      case Operation::EQU:
        return " EQU: ";
      case Operation::NE:
        return " NE: ";
      case Operation::JT:
        return " JT: ";
      case Operation::JF:
        return " JF: ";
      case Operation::MARKER:
        return " MARKER: ";
      default:
        return " ";
      }
    }
  }

  void print_triples(){
    for(auto *triple: m_current_fn->m_triples){
      std::cout<<"t"<<triple->m_index<<return_operation(triple->m_operation);
      
      print_operand(triple->m_op_1);
      print_operand(triple->m_op_2);
      std::cout<<std::endl;
    }
  }

  void build_program(){
    m_program->m_functions=m_functions;
  }
};

int main(int argc, char ** argv)
{
  FILE *input;
  int quiet = 0;
  char *filename = NULL;

  if (argc > 1) {
    if (strcmp(argv[1], "-s") == 0) {
      quiet = 1;
      if (argc > 2) {
        filename = argv[2];
      } else {
        input = stdin;
      }
    } else {
      filename = argv[1];
    }
  }

  if (filename) {
    input = fopen(filename, "r");
    if (!input) {
      usage();
      exit(1);
    }
  } else input = stdin;
  /* The default entry point is used. For other options see Parser.H */
  Program *parse_tree = NULL;
  try {
  parse_tree = pProgram(input);
  } catch( parse_error &e) {
     std::cerr << "Parse error on line " << e.getLine() << "\n";
  }

  std::vector<Function*> functions;
  IntermediateProgram int_prog;
  MyVisitor my_visitor{&int_prog};

  parse_tree->accept(&my_visitor);
  my_visitor.print_functions();
  std::cout<<"Printing tripples : "<<std::endl;
  my_visitor.print_triples();

  quiet=true;
  if (parse_tree)
  {
    printf("\nParse Successful!\n");
    if (!quiet) {
      printf("\n[Abstract Syntax]\n");
      ShowAbsyn *s = new ShowAbsyn();
      printf("%s\n\n", s->show(parse_tree));
      printf("[Linearized Tree]\n");
      PrintAbsyn *p = new PrintAbsyn();
      printf("%s\n\n", p->print(parse_tree));
    }
    delete(parse_tree);
    return 0;
  }

  return 1;
}

