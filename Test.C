/* File generated by the BNF Converter (bnfc 2.9.5). */

/************************* Compiler Front-End Test *************************/
/*                                                                         */
/*  This test will parse a file, print the abstract syntax tree, and then  */
/*  pretty-print the result.                                               */
/*                                                                         */
/***************************************************************************/

#include <cstdio>
#include <string>
#include <map>
#include <iostream>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include "ParserError.H"
#include "DataStructure.h"
#include "DataStructure.cpp"
#include "Skeleton.H"
#include "Skeleton.C"
#include <format>

void usage() {
  printf("usage: Call with one of the following argument combinations:\n");
  printf("\t--help\t\tDisplay this help message.\n");
  printf("\t(no arguments)\tParse stdin verbosely.\n");
  printf("\t(files)\t\tParse content of files verbosely.\n");
  printf("\t-s (files)\tSilent mode. Parse content of files silently.\n");
}

class IntermediateProgram{
private:
public:
  std::vector<Function*>m_functions;
  IntermediateProgram(){}
  ~IntermediateProgram(){
    for(auto *fn: m_functions)
      delete fn;
  }
};

class ErrorList {
public:
  std::vector<Error*> m_errors;
  void add_error(int l,std::string &msg){
    m_errors.push_back(new Error{(size_t)l,msg});
  }

  void print_errors(){
    for(auto *err : m_errors){
      std::string error = std::format("Line: {} | Message: {}",err->m_line,err->m_msg);
      std::cout<<error<<std::endl;
    }
  }

  bool errors_occured(){return m_errors.size()>0;}

  ~ErrorList(){
    for(auto *err : m_errors)
      delete err;
  }
};

class TrueFalseLabel{
public:
  Label *m_false_label;
  Label *m_true_label;
  TrueFalseLabel(Label *f_label,Label * t_label):m_false_label{f_label},m_true_label{t_label}{}
  TrueFalseLabel():m_false_label{nullptr},m_true_label{nullptr}{}
};

class MyVisitor:public Skeleton {
private:
  IntermediateProgram * m_program;
  std::vector<Label*> m_labels;
  std::vector<Function*> m_functions;
  std::vector<std::string> m_generated_code;
  ErrorList m_error_list;
  SymbolTable m_symbol_table;
  std::map<Visitable*,Operand> m_nodes_to_operands;
  // std::map<Visitable*,TrueFalseLabel*> m_node_to_true_false_label; // these labels indicate where to go
  std::vector<TrueFalseLabel> m_true_false_label_stack;
  Function * m_current_fn;
  Argument * m_current_arg;
  std::string m_current_line;
  DataType m_last_visited_type;
  OperandCategory m_last_expr_cat;
  Operation m_current_operation;
public:
  
  bool errors_occured(){
    return m_error_list.errors_occured();
  }
  void print_errors(){
    m_error_list.print_errors();
  }

  void add_predefined_functions(){
    // void printInt(int)
    Function * print_int = new Function{PredefinedFunction::PRINTINT};
    print_int->m_name = "printInt";
    print_int->m_return_type = DataType::VOID;
    print_int->m_arguments.push_back(new Argument{DataType::INT,"value"});

    Function * print_string = new Function{PredefinedFunction::PRINTSTRING};
    print_string->m_name = "printString";
    print_string->m_return_type=DataType::VOID;
    print_string->m_arguments.push_back(new Argument{DataType::STRING,"value"});

    Function * error = new Function{PredefinedFunction::ERROR};
    error->m_name = "error";
    error->m_return_type=DataType::VOID;

    Function * read_int = new Function{PredefinedFunction::READINT};
    read_int->m_name = "readInt";
    read_int->m_return_type = DataType::INT;

    Function * read_string = new Function{PredefinedFunction::PRINTSTRING};
    read_string->m_name="readString";
    read_string->m_return_type=DataType::STRING;

    m_symbol_table.add(print_int->m_name,print_int);
    m_symbol_table.add(print_string->m_name,print_string);
    m_symbol_table.add(error->m_name,error);
    m_symbol_table.add(read_int->m_name,read_int);
    m_symbol_table.add(read_string->m_name,read_string);

  }

  MyVisitor(IntermediateProgram *prog):m_program{prog}{}
  void visitProg(Prog *p) override {
    m_symbol_table.push();
    // load predefined functions
    add_predefined_functions();
    std::cout<<"Begin Program"<<std::endl;
    p->listtopdef_->accept(this);
    std::cout<<"End Program"<<std::endl;
    m_symbol_table.pop();
  }
  
  void visitFnDef(FnDef *p) override {
    m_current_fn = new Function;
    m_symbol_table.add(p->ident_,m_current_fn);
    m_symbol_table.push();
    std::cout<<"Begin function definition"<<std::endl;
    std::cout<<"Function name : "<<p->ident_<<std::endl;
    m_current_fn->m_name=p->ident_;
    p->type_->accept(this);
    m_current_fn->m_return_type=m_last_visited_type;
    p->listarg_->accept(this);
    p->block_->accept(this);
    std::cout<<"End function definition"<<std::endl;
    m_functions.push_back(m_current_fn);
    m_symbol_table.pop();
  }

  void visitEApp(EApp *p) override{
    
    Function * fn = m_symbol_table.get_function(p->ident_);
    if(fn==nullptr){
      std::string msg=std::format("Undefined function {}",p->ident_); 
      m_error_list.add_error(p->line_number,msg);
      return;
    }
      
    if(fn->m_arguments.size() != p->listexpr_->size()){
      std::string msg=std::format("Incorrect number of arguments, expected: {}, passed {}",fn->m_arguments.size(),p->listexpr_->size());
      m_error_list.add_error(p->line_number,msg);
      return;
    }
  
    if(p->listexpr_!=nullptr)
      p->listexpr_->accept(this);
    
    for(size_t i=0;i<fn->m_arguments.size();i++){
      DataType fn_argument_type = fn->m_arguments[i]->m_type;
      DataType current_argument_type = m_nodes_to_operands[p->listexpr_->at(i)].get_type();
      int line_number = p->listexpr_->at(i)->line_number;
      // to-do implicit conversion

      // we assume that as for now they will have the same type
      if(fn_argument_type!=current_argument_type){
        std::string msg=std::format("Mismatched argument type {}, expected type {}, provided {}",i+1,data_type_to_string(fn_argument_type),data_type_to_string(current_argument_type));
        m_error_list.add_error(line_number,msg);
      }
    }

    for(auto *expr: *p->listexpr_){
      push_triple(Operation::PARAM,m_nodes_to_operands.at(expr));
    }

    m_nodes_to_operands[p] = push_triple(Operation::CALL,m_symbol_table.get_function(p->ident_),Constant{(int)p->listexpr_->size()});
  }
 
  void visitBlk(Blk *p){
    m_symbol_table.push();
    for(auto statement : *p->liststmt_){
      statement->accept(this);
    }
    m_symbol_table.pop();
  }

  void visitInt(Int *x) override{
    m_last_visited_type = DataType::INT;
  }

  void visitVoid(Void *p) override{
    m_last_visited_type = DataType::VOID;
  }

  void visitBool(Bool *p) override{
    m_last_visited_type=DataType::BOOL;
  }
  
  void visitListArg(ListArg *p) override{
    std::cout<<"List of arguments"<<std::endl;
    for(auto item : *p){
      m_current_arg=new Argument;
      item->accept(this);
      m_current_fn->m_arguments.push_back(m_current_arg);
    }
  }

  void visitAr(Ar *p) override{
    std::cout<<"Argument Identifier: "<<p->ident_<<std::endl;
    m_current_arg->m_identifier=p->ident_;
    p->type_->accept(this);
    m_current_arg->m_type=m_last_visited_type;
  }

  void visitDecl(Decl *p) override{
    p->type_->accept(this);
    for(auto item : *p->listitem_)
      item->accept(this);
  }
  
  void visitInit(Init *p) override {
    Variable *variable = new Variable{p->ident_,m_last_visited_type};
    bool result = m_symbol_table.add(p->ident_,variable);
    if(!result){
      std::string msg=std::format("Redefinition of variable: {}",p->ident_); 
      m_error_list.add_error(p->line_number,msg);
      return;
    }
      
    p->expr_->accept(this);
    if(!result)
      return;
    std::cout<<"Initialized Identifier: "<<p->ident_<<std::endl;
    push_triple(Operation::ASSIGN,variable,m_nodes_to_operands[p->expr_]);
    m_current_fn->m_variables.push_back(variable);
  }

  void visitWhile(While *p) override {
    Label * cond_label = create_label();
    Triple * cond_marker = push_triple(Operation::MARKER);
    cond_label->m_jump_to=cond_marker;

    p->expr_->accept(this);
    Label *end_label = create_label();
    push_triple(Operation::JF,m_nodes_to_operands.at(p->expr_),{end_label});

    p->stmt_->accept(this);
    push_triple(Operation::JMP,{cond_label});
    Triple *end_marker = push_triple(Operation::MARKER);
    end_label->m_jump_to = end_marker;

  }


  // S -> (B) S1 
  // the data about True and Flase jumps will be stored on the stack
  void visitCond(Cond *p) override {
    Label *if_false = create_label();
    Label *if_true = create_label();
    m_true_false_label_stack.push_back({if_false,if_true});

    p->expr_->accept(this);
    m_true_false_label_stack.pop_back();

    //Jump True
    if_true->m_jump_to = push_triple(Operation::MARKER);
    p->stmt_->accept(this);
    Triple *special_triple=push_triple(Operation::MARKER);

    //Jump False
    if_false->m_jump_to = special_triple;
  }
  //  void visitNot(Not *p);
  // we switch the order of jumps
  void visitNot(Not *p) override {
    m_true_false_label_stack.push_back({m_true_false_label_stack.back().m_true_label,m_true_false_label_stack.back().m_false_label});
    p->expr_->accept(this);
    m_true_false_label_stack.pop_back();
  }

  void visitCondElse(CondElse *p) override{
    Label *if_false = create_label();
    Label *if_true = create_label();
    Label *past_else = create_label();

    m_true_false_label_stack.push_back({if_false,if_true});
    p->expr_->accept(this);
    m_true_false_label_stack.pop_back();

    if_true->m_jump_to = push_triple(Operation::MARKER);
    p->stmt_1->accept(this);
    push_triple(Operation::JMP,past_else);

    if_false->m_jump_to = push_triple(Operation::MARKER);
    p->stmt_2->accept(this);
    past_else->m_jump_to=push_triple(Operation::MARKER);

  }

  void visitAss(Ass *ass) override {
    ass->expr_->accept(this);
    // m_symbol_table
    m_nodes_to_operands[ass->expr_]=push_triple(Operation::ASSIGN,m_symbol_table.get_variable(ass->ident_),m_nodes_to_operands[ass->expr_]);
  }

  void visitNoInit(NoInit *p) override {
    std::cout<<"NoInit: "<<p->ident_<<std::endl;
    Variable *variable = new Variable{p->ident_,m_last_visited_type};
    m_symbol_table.add(p->ident_,variable);
    m_current_fn->m_variables.push_back(variable);
  }

  void visitRet(Ret *p) override{
    p->expr_->accept(this);  
    push_triple(Operation::RETURN,m_nodes_to_operands[p->expr_]);
  }

  void visitVRet(VRet *p) override{ 
    push_triple(Operation::RETURN);
  }

  std::string type_to_string(DataType dt){
    switch (dt)
    {
    case DataType::INT:
      return "int";
    case DataType::BOOL:
      return "bool";
    case DataType::STRING:
      return "string";
    case DataType::VOID:
      return "void";
    case DataType::ERROR:
      return "error";
    default:
      return "";
      break;
    }
  }
  
  void visitELitInt(ELitInt *p) override{
    Constant constant{p->integer_};
    m_nodes_to_operands[p]=constant;
  }

  void visitELitTrue(ELitTrue *p) override {
    m_nodes_to_operands[p]= {true};
  }

  void visitELitFalse(ELitFalse *p) override{
    m_nodes_to_operands[p]= {false};
  }
  
  void visitEString(EString *p) override {
    m_nodes_to_operands[p]= {p->string_};
  }

  DataType deduce_bool_type_one_argument(DataType op_1_type){
    if(op_1_type==DataType::BOOL)
      return DataType::BOOL;
    else
      return DataType::ERROR;
  }

  DataType deduce_bool_type(DataType op_1_type,DataType op_2_type){
    if(op_1_type==DataType::INT && op_2_type==DataType::INT)
      return DataType::BOOL;
    else if(op_1_type==DataType::BOOL && op_2_type==DataType::BOOL)
      return DataType::BOOL;
    else
      return DataType::ERROR;
  }

  DataType deduce_arithmetic_type(DataType op_1_type,DataType op_2_type){
    if(op_1_type!=op_2_type)
      return DataType::ERROR;

    if(op_1_type==DataType::INT)
      return DataType::INT;
    else 
      return DataType::ERROR;
  }

  DataType deduce_arithmetic_type_add(DataType op_1_type,DataType op_2_type){
    if(op_1_type!=op_2_type)
      return DataType::ERROR;
    
    if(op_1_type==DataType::INT)
      return DataType::INT;
    else if(op_1_type==DataType::STRING)
      return DataType::STRING;
    else
      return DataType::ERROR;
  }

  DataType deduce_arithmetical_neg(DataType op_1_type){
    if(op_1_type==DataType::INT)
      return DataType::INT;
    else
      return DataType::ERROR;
  }

  DataType deduce_type(Triple *triple){
    DataType op_1_type=triple->m_op_1.get_type();
    DataType op_2_type=triple->m_op_1.get_type();

    switch (triple->m_operation)
    {
    case Operation::ADD:
      return deduce_arithmetic_type_add(op_1_type,op_2_type);
    case Operation::MUL:
    case Operation::MOD:
    case Operation::SUB:
    case Operation::DIV:
      return deduce_arithmetic_type(op_1_type,op_2_type);
    case Operation::NOT: //logical negation
      return deduce_bool_type_one_argument(op_1_type);
    case Operation::ASSIGN:
      return op_1_type;
    case Operation::NEG:
      return deduce_arithmetical_neg(op_1_type);
    case Operation::AND:
    case Operation::OR:
    case Operation::LTH:
    case Operation::LE:
    case Operation::GTH:
    case Operation::GE:
    case Operation::EQU:
    case Operation::NE:
      return deduce_bool_type(op_1_type,op_2_type);
    case Operation::JT:
    case Operation::JF:
    case Operation::JMP:
      return DataType::VOID;
    case Operation::CALL:
      return op_1_type;
    case Operation::PARAM:
      return DataType::VOID;
    case Operation::RETURN:
      return DataType::VOID; // because it does not have a type
    case Operation::MARKER:
      return DataType::VOID;
    default:
      throw 0;
    }
  }
  
  Triple* push_triple(Operation operation,const Operand &op_1={},const Operand &op_2={}){
    Triple *triple = new Triple{m_current_fn->m_triples.size()+1,operation,op_1,op_2};
    DataType deduced_type = deduce_type(triple);
    triple->m_data_type=deduced_type;

    m_current_fn->m_triples.push_back(triple);
    return triple;
  }

  Label* create_label(){
    Label *label = new Label{m_labels.size()};
    m_labels.push_back(label);
    return label;
  }

  void visitEVar(EVar *p)override{
    m_nodes_to_operands[p] = m_symbol_table.get_variable(p->ident_); //lokalnie tymczasowo tworzony jest operand
  }

  void visitEAdd(EAdd *p) override {
    p->expr_1->accept(this);
    p->addop_->accept(this); // here we want to figure the correct operation
    p->expr_2->accept(this);
    
    m_nodes_to_operands[p] = push_triple(m_current_operation,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitEMul(EMul *p) override{
    p->expr_1->accept(this);

    p->mulop_->accept(this);

    p->expr_2->accept(this);
    m_nodes_to_operands[p] = push_triple(m_current_operation,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
  }

  void visitLTH(LTH *p) override {
    m_current_operation = Operation::LTH;
  }

  void visitLE(LE *p) override {
    m_current_operation = Operation::LE;
  }

  void visitGTH(GTH *p) override {
    m_current_operation = Operation::GTH;
  }

  void visitGE(GE *p) override {
    m_current_operation = Operation::GE;
  }

  void visitEQU(EQU *p) override{
    m_current_operation = Operation::EQU;
  }

  void visitNE(NE *p) override{
    m_current_operation=Operation::NE;
  }

  void visitERel(ERel *p) override {
    p->relop_->accept(this);
    p->expr_1->accept(this);
    p->expr_2->accept(this);
    Operand op_1 = m_nodes_to_operands.at(p->expr_1);
    Operand op_2 = m_nodes_to_operands.at(p->expr_2);
    
    m_nodes_to_operands[p]=push_triple(m_current_operation,m_nodes_to_operands.at(p->expr_1),m_nodes_to_operands.at(p->expr_2));
    push_triple(Operation::JF,m_nodes_to_operands[p],m_true_false_label_stack.back().m_false_label);
    push_triple(Operation::JT,m_nodes_to_operands[p],m_true_false_label_stack.back().m_true_label);
  }

  void visitEAnd(EAnd *p) override{
    // m_true_false_label_stack.back()
    Label *left_true = create_label();
    // Label *and_false = create_label();
    m_true_false_label_stack.push_back({m_true_false_label_stack.back().m_false_label,left_true});
    p->expr_1->accept(this);
    // if_true->m_jump_to = push_triple(Operation::MARKER);
    left_true->m_jump_to = push_triple(Operation::MARKER);
    m_true_false_label_stack.pop_back();
    
    //right expr
    m_true_false_label_stack.push_back(m_true_false_label_stack.back());
    p->expr_2->accept(this);
    m_true_false_label_stack.pop_back();
  }

  void visitEOr(EOr *p){
    //what if left expr is false 
    Label *left_false = create_label();

    m_true_false_label_stack.push_back({left_false,m_true_false_label_stack.back().m_true_label});
    p->expr_1->accept(this);
    m_true_false_label_stack.pop_back();

    left_false->m_jump_to = push_triple(Operation::MARKER);
    m_true_false_label_stack.push_back(m_true_false_label_stack.back());
    p->expr_2->accept(this);
    m_true_false_label_stack.pop_back();
  }

  
  void visitPlus(Plus *p) override {
    m_current_operation=Operation::ADD;
  }

  void visitDiv(Div *p) override{
    std::cout<<"Entering DIV: "<<std::endl;
    m_current_operation=Operation::DIV;
  }

  void visitMinus(Minus *p) override{
    m_current_operation=Operation::SUB;
  }

  void visitTimes(Times *p) override {
    m_current_operation=Operation::MUL;
  }

  void visitMod(Mod *mod) override {
    m_current_operation=Operation::MOD;
  }
  
  void print_functions(){
    for(auto *fn : m_functions){ //for readability
      std::cout<<"Function name: "<<fn->m_name<<std::endl;
      std::cout<<"Function return type: "<<type_to_string(fn->m_return_type)<<std::endl;
      std::cout<<"Arguments: "<<std::endl;
      for(auto *arg : fn->m_arguments)
        std::cout<<" Identifier: "<<arg->m_identifier<<"\n Type :"<<type_to_string(arg->m_type)<<std::endl;
    }
  }

  void print_constant(const Constant &constant){
    switch (constant.m_type)
    {
    case DataType::INT:
      std::cout<<"INT("<<constant.u.integer<<") ";
      break;
    case DataType::BOOL:
      std::cout<<"BOOL("<<constant.u.boolean<<")";
      break;
    case DataType::STRING:
      std::cout<<"STRING("<<constant.u.str<<")";
      break;
    default:
      break;
    }
  }
  
  void print_operand(const Operand &operand){
    switch (operand.m_category)
      {
      case OperandCategory::CONSTANT:
        print_constant(operand.m_constant);
        break;
      case OperandCategory::VARIABLE:
        std::cout<<operand.m_var->m_ident<<" ";
        break;
      case OperandCategory::TRIPLE:
        std::cout<<"t"<<operand.m_triple->m_index<<" ";
        break;
      case OperandCategory::EMPTY:
        std::cout<<"- ";
        break;
      case OperandCategory::LABEL:
        if(operand.m_label->m_jump_to!=nullptr)
          std::cout<<"t"<<operand.m_label->m_jump_to->m_index<<" ";
        else
          std::cout<<"No label set ";
        break;
      case OperandCategory::FUNCTION:
          std::cout<<operand.m_function->m_name<<" ";
          break;
      default:
        throw 0; //it is yet to be changed
        break;
    }
  }

  std::string return_operation(Operation operation){
    switch (operation)
    {
      case Operation::ADD:{
        return " ADD: ";
      case Operation::ASSIGN:
        return " ASSIGN: ";
      case Operation::MUL:
        return " MUL: ";
      case Operation::SUB:
        return " SUB: ";
      case Operation::DIV:
        return " DIV: ";
      case Operation::AND:
        return " AND: ";
      case Operation::OR:
        return " OR: ";
      case Operation::LTH:
        return " LTH: ";
      case Operation::LE:
        return " LE: ";
      case Operation::GTH:
        return " GTH: ";
      case Operation::GE:
        return " GE: ";
      case Operation::EQU:
        return " EQU: ";
      case Operation::NE:
        return " NE: ";
      case Operation::JT:
        return " JT: ";
      case Operation::JF:
        return " JF: ";
      case Operation::MARKER:
        return " MARKER: ";
      case Operation::JMP:
        return " JUMP: ";
      case Operation::CALL:
        return " CALL: ";
      case Operation::PARAM:
        return " PARAM: ";
      case Operation::RETURN:
        return " RETURN: ";
      default:
        return " ";
      }
    }
  }

  void print_functions_triples(){
    for(auto *fn : m_functions){
      std::cout<<"Function: "<<fn->m_name<<std::endl;
      print_triples(fn);
    }
    std::cout<<std::endl;
  }
  void print_triples(Function * fn){
    for(auto *triple: fn->m_triples){
      std::cout<<"t"<<triple->m_index<<return_operation(triple->m_operation);
      
      print_operand(triple->m_op_1);
      print_operand(triple->m_op_2);
      // return_
      std::cout<<"Type: "<<data_type_to_string(triple->m_data_type)<<" ";
      std::cout<<std::endl;
    }
  }

  void build_program(){
    m_program->m_functions=m_functions;
  }
};

int main(int argc, char ** argv)
{
  FILE *input;
  int quiet = 0;
  char *filename = NULL;

  if (argc > 1) {
    if (strcmp(argv[1], "-s") == 0) {
      quiet = 1;
      if (argc > 2) {
        filename = argv[2];
      } else {
        input = stdin;
      }
    } else {
      filename = argv[1];
    }
  }

  if (filename) {
    input = fopen(filename, "r");
    if (!input) {
      usage();
      exit(1);
    }
  } else input = stdin;
  /* The default entry point is used. For other options see Parser.H */
  Program *parse_tree = NULL;
  try {
  parse_tree = pProgram(input);
  } catch( parse_error &e) {
     std::cerr << "Parse error on line " << e.getLine() << "\n";
  }

  std::vector<Function*> functions;
  IntermediateProgram int_prog;
  MyVisitor my_visitor{&int_prog};

  parse_tree->accept(&my_visitor);
  my_visitor.print_functions();
  std::cout<<"Printing tripples : "<<std::endl;
  my_visitor.print_functions_triples();
  if(my_visitor.errors_occured()){
    my_visitor.print_errors();
  }

  quiet=true;
  if (parse_tree)
  {
    printf("\nParse Successful!\n");
    if (!quiet) {
      printf("\n[Abstract Syntax]\n");
      ShowAbsyn *s = new ShowAbsyn();
      printf("%s\n\n", s->show(parse_tree));
      printf("[Linearized Tree]\n");
      PrintAbsyn *p = new PrintAbsyn();
      printf("%s\n\n", p->print(parse_tree));
    }
    delete(parse_tree);
    return 0;
  }

  return 1;
}

