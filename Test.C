/* File generated by the BNF Converter (bnfc 2.9.5). */

/************************* Compiler Front-End Test *************************/
/*                                                                         */
/*  This test will parse a file, print the abstract syntax tree, and then  */
/*  pretty-print the result.                                               */
/*                                                                         */
/***************************************************************************/

#include <cstdio>
#include <string>
#include <map>
#include <iostream>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include "ParserError.H"
#include "DataStructure.h"
#include "DataStructure.cpp"
#include "Skeleton.H"
#include "Skeleton.C"

void usage() {
  printf("usage: Call with one of the following argument combinations:\n");
  printf("\t--help\t\tDisplay this help message.\n");
  printf("\t(no arguments)\tParse stdin verbosely.\n");
  printf("\t(files)\t\tParse content of files verbosely.\n");
  printf("\t-s (files)\tSilent mode. Parse content of files silently.\n");
}

// section for processing the tree
void rec_tree(){

}

class IntermediateProgram{
private:

public:
  std::vector<Function*>m_functions;
  IntermediateProgram(){}
  ~IntermediateProgram(){
    for(auto *fn: m_functions)
      delete fn;
  }

};

// {
//   int x; // block A
//   {
//     int x; // block B
//   }
// }

class MyVisitor:public Skeleton {
private:
  IntermediateProgram * m_program;
  std::vector<Function*> m_functions;
  std::vector<std::string> m_generated_code;
  std::map<std::string,Variable*> m_symbol_table; 
  Function * m_current_fn;
  Argument * m_current_arg;
  std::string m_current_line;
  DataType m_last_visited_type;
public:
  MyVisitor(IntermediateProgram *prog):m_program{prog}{}
  void visitProg(Prog *p) override {
    std::cout<<"Begin Program"<<std::endl;
    p->listtopdef_->accept(this);
    std::cout<<"End Program"<<std::endl;
  }
  
  void visitFnDef(FnDef *p) override {
    m_current_fn = new Function;
    std::cout<<"Begin function definition"<<std::endl;
    std::cout<<"Function name : "<<p->ident_<<std::endl;
    m_current_fn->m_name=p->ident_;
    // m_type_processing_state=TypeProcessingState::RETURN_TYPE;
    p->type_->accept(this);
    m_current_fn->m_return_type=m_last_visited_type;
    p->listarg_->accept(this);
    p->block_->accept(this);
    std::cout<<"End function definition"<<std::endl;
    m_functions.push_back(m_current_fn);
  }

  void visitBlk(Blk *p){
    for(auto statement : *p->liststmt_){
      statement->accept(this);
    }
  }

  void visitInt(Int *x) override{
    m_last_visited_type=DataType::INT;
  }

  void visitListArg(ListArg *p) override{
    std::cout<<"List of arguments"<<std::endl;
    for(auto item : *p){
      m_current_arg=new Argument;
      item->accept(this);
      m_current_fn->m_arguments.push_back(m_current_arg);
    }
  }

  virtual void visitAr(Ar *p) override{
    std::cout<<"Argument Identifier: "<<p->ident_<<std::endl;
    m_current_arg->m_identifier=p->ident_;
    p->type_->accept(this);
    m_current_arg->m_type=m_last_visited_type;
  }
  // int x,y,z;
  void visitDecl(Decl *p) override{
    for(auto item : *p->listitem_)
      item->accept(this);
  }
  
  void visitInit(Init *p) override{
    // p->expr_->accept
    // Variable *variable = new Variable();
    // m_symbol_table.insert(p->ident_,{});
    std::cout<<"Initialized Identifier: "<<p->ident_<<std::endl;
  }

  void visitNoInit(NoInit *p) override {
    std::cout<<"NoInit: "<<p->ident_<<std::endl;
  }
  std::string type_to_string(DataType dt){
    switch (dt)
    {
    case DataType::INT:
      return "int";
    case DataType::BOOL:
      return "bool";
    case DataType::STRING:
      return "STRING";
    default:
      return "";
      break;
    }
  }
  
  void visitELitInt(ELitInt *p) override{
    
  }

  void visitEAdd(EAdd *p) override {
    // p->
    // p->expr_1->accept();
    p->expr_2->accept(this);
  }


  void print_functions(){
    for(auto *fn : m_functions){ //for readability
      std::cout<<"Function name: "<<fn->m_name<<std::endl;
      std::cout<<"Function return type: "<<type_to_string(fn->m_return_type)<<std::endl;
      std::cout<<"Arguments: "<<std::endl;
      for(auto *arg : fn->m_arguments)
        std::cout<<" Indentifier: "<<arg->m_identifier<<"Type :"<<type_to_string(arg->m_type)<<std::endl;
    }
  }

  void build_program(){
    m_program->m_functions=m_functions;
  }
};

int main(int argc, char ** argv)
{
  FILE *input;
  int quiet = 0;
  char *filename = NULL;

  if (argc > 1) {
    if (strcmp(argv[1], "-s") == 0) {
      quiet = 1;
      if (argc > 2) {
        filename = argv[2];
      } else {
        input = stdin;
      }
    } else {
      filename = argv[1];
    }
  }

  if (filename) {
    input = fopen(filename, "r");
    if (!input) {
      usage();
      exit(1);
    }
  } else input = stdin;
  /* The default entry point is used. For other options see Parser.H */
  Program *parse_tree = NULL;
  try {
  parse_tree = pProgram(input);
  } catch( parse_error &e) {
     std::cerr << "Parse error on line " << e.getLine() << "\n";
  }

  std::vector<Function*> functions;
  IntermediateProgram int_prog;
  MyVisitor my_visitor{&int_prog};

  parse_tree->accept(&my_visitor);
  my_visitor.print_functions();

  quiet=true;
  if (parse_tree)
  {
    printf("\nParse Successful!\n");
    if (!quiet) {
      printf("\n[Abstract Syntax]\n");
      ShowAbsyn *s = new ShowAbsyn();
      printf("%s\n\n", s->show(parse_tree));
      printf("[Linearized Tree]\n");
      PrintAbsyn *p = new PrintAbsyn();
      printf("%s\n\n", p->print(parse_tree));
    }
    delete(parse_tree);
    return 0;
  }
  // DataType t;

  return 1;
}

